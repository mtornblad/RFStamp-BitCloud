/**************************************************************************//**
\file  halLowLevelInit.c

\brief
   Implementation of the basic initialization module.

\author
    Atmel Corporation: http://www.atmel.com \n
    Support email: avr@atmel.com

  Copyright (c) 2008-2012, Atmel Corporation. All rights reserved.
  Licensed under Atmel's Limited License Agreement (BitCloudTM).

\internal
  History:
    07/04/14 karthik.p_u - Created
*******************************************************************************/
/******************************************************************************
                   Includes section
******************************************************************************/
#include <atsamr21.h>
#include <core_cm0plus.h>
#include <sysTypes.h>
#include <halClkCtrl.h>
#include <sysEvents.h>
#include <halRfCtrl.h>

/******************************************************************************
                   Define(s) section
******************************************************************************/
#define DFLL_COARSE_STEP_SIZE        (0x1f/4)
#define DFLL_FINE_STEP_SIZE          (0xff/4)
// XOSC32K Output Freq if en32k in XOSC32K Reg is enabled
#define XOSC32K_CLK                  (32768ul)
// The Fixed Output Freq of DFLL
#define DFLL_OUTPUT_FREQ             48000000ul
// The multiplication factor needed to get 48MHz out of DFLL
#define DFLL_MUL_48MHz               (DFLL_OUTPUT_FREQ/XOSC32K_CLK)

#if defined (HAL_USE_USB)
#define NVM_SW_CALIB_DFLL48M_COARSE_VAL   58
#define NVM_SW_CALIB_DFLL48M_FINE_VAL     64
#endif

/******************************************************************************
                   Prototypes section
******************************************************************************/
#ifndef CLKM
#if (defined (HAL_USE_USB) && !defined(HAL_4MHz) && !defined(HAL_32MHz))
static void halUsbConfigCpuDFLL(void);
#endif

#if (defined(HAL_4MHz) || defined(HAL_8MHz)) && (!defined(HAL_USE_USB))
/**************************************************************************//**
\brief Run CPU from internal 8Mhz RC Oscillator 

\param[in] div - The division factor to be applied before giving the RC clock \
                 to CPU
******************************************************************************/
static void halConfigCpuIntRC(uint8_t div);

#elif defined(HAL_16MHz) || defined(HAL_24MHz) || defined(HAL_48MHz)
/**************************************************************************//**
\brief Run CPU from XOSC32K Oscillator through DFLL to run at \
       different frequencies. 

\param[in] div - The division factor to be applied before giving the DFLL    \
                 clock to CPU.
\param[in] mul - The multiplication factor to be applied on DFLL to multiply \
                 the RC clock.
******************************************************************************/
#if !defined (HAL_USE_USB)
static void halConfigCpuDFLL(uint16_t div, uint16_t mul);
#endif
#endif // defined(HAL_4MHz) || defined(HAL_8MHz)
#endif

/**************************************************************************//**
\brief Initialize the Peripherals with Internal RC oscillator.

\param[in] div - The division factor to be applied before giving the Internal \
                 RC clock to Peripherals.
******************************************************************************/
static void halConfigPeriIntRC(uint8_t div);

#ifdef CLKM
/**************************************************************************//**
\brief Initialization of the CLKM to produce appropriate frequency and also to 
handle the switch from CLKM to OSC8M duing sleep.
******************************************************************************/
void halConfigClkm(SYS_EventId_t eventId, SYS_EventData_t data);

#if !defined (HAL_32MHz)
/**************************************************************************//**
\brief Configures DFLL with CLKM source
******************************************************************************/
static void halConfigDfllClkm (void);
#endif
/**************************************************************************//**
\brief Routing CLKM to CPU
******************************************************************************/
static void halRouteClkm(void);

/******************************************************************************
  Set external frequency generated by RF chip.
  Parameters: none.
  Returns: none.
******************************************************************************/
extern void phySetFreq(void);

/**************************************************************************//**
\brief Routing Source Generator output to Generator 3
******************************************************************************/
static void halConfigPeriClkm(uint8_t div, uint8_t source);

/**************************************************************************//**
\brief Routing Source Generator output to Generator 0
******************************************************************************/
static void halConfigCpuClkm(uint8_t div, uint8_t source);

/******************************************************************************
                        Static variables section.
******************************************************************************/
SYS_EventReceiver_t initCpuToClkm = { .func = halConfigClkm};
#endif

/******************************************************************************
                              Implementations section
******************************************************************************/

/**************************************************************************//**
\brief Run device from 8MHz RC clock
******************************************************************************/
void halSwitchToRcClock(void)
{
  // NVM wait cycles
  // These Wait cycles are need without which CPU will stop
#if defined(HAL_16MHz) || defined(HAL_24MHz) || defined(HAL_32MHz)
  // The wait cycles are set to 2 as per datasheet for voltages from 1V8 to 3V6
  NVMCTRL_CTRLB = (NVMCTRL_CTRLB & (~NVMCTRL_CTRLB_RWS_MSK)) | NVMCTRL_CTRLB_RWS(2);
#elif defined(HAL_48MHz)
  // The wait cycles are set to 3 as per datasheet for voltages from 1V8 to 3V6
  NVMCTRL_CTRLB = (NVMCTRL_CTRLB & (~NVMCTRL_CTRLB_RWS_MSK)) | NVMCTRL_CTRLB_RWS(3);
#endif /* NVM wait cycles */

  // setting the pre-scalar
  SYSCTRL_OSC8M_s.presc = 0x0;
  // Enabling the oscillator
  SYSCTRL_OSC8M_s.enable = 0x1;

  // Routing the internal RC as source to generator 0
  GCLK_GENCTRL = GCLK_GENCTRL_ID(GCLK_GEN_0) | GCLK_GENCTRL_SRC(OSC8M) | GCLK_GENCTRL_GENEN;
  halGclkSync();

  // Check if the oscillator is ready
  halCheckIntRcReady();

  // Setting the pre-scalar for generator 0
  GCLK_GENDIV = GCLK_GENDIV_ID(GCLK_GEN_0) | GCLK_GENDIV_DIV(0);
  halGclkSync();
}
/**************************************************************************//**
\brief Run device from active clock (intended at configuration)
******************************************************************************/
void halSwitchToActiveClock(void)
{
  // Configuring the peripheral frequency
  // The peripherals will always be running at Internal 8Mhz irrespective of CPU freq
  // Only Exception is For HAL_4MHz the Peripherals also run at 4Mhz
#if defined(HAL_4MHz)
  // The division factor 2 is in place as to make the Peripheral frequency same as CPU Frequency.
  halConfigPeriIntRC(2);
#elif defined(HAL_8MHz) || defined(HAL_16MHz) || defined(HAL_24MHz) || defined(HAL_32MHz) || defined(HAL_48MHz)
  // No division factor is needed as it configured for 8MHz
  halConfigPeriIntRC(0);
#endif /* Configuring the Peripheral Freq */

#ifndef CLKM
  // Configuring the CPU Freq
  // Configuring Internal RC 8MHz as clock for CPU
#if defined(RC_INTERNAL)

  #if defined(HAL_4MHz)
    #if defined (HAL_USE_USB)
      #error "Disable USB in HAL for 4Mhz CPU"
    #endif
    // configuring CPU Freq for 4MHz 
    halConfigCpuIntRC(2);
  #elif defined(HAL_8MHz)
    #if defined (HAL_USE_USB)
      if (!(SYSCTRL_DFLLCTRL & SYSCTRL_DFLLCTRL_ENABLE))
        halUsbConfigCpuDFLL();
    #else
      // configuring CPU Freq for 8MHz 
      halConfigCpuIntRC(0);
    #endif
  #elif defined(HAL_16MHz) || defined(HAL_24MHz) || defined(HAL_32MHz) || defined(HAL_48MHz)
    #error "Choose HAL_CLOCK_SOURCE as XOSC32K when choosing HAL_16MHz, HAL_24MHz, HAL_32MHz and HAL_48MHz in HAL\Configuration" 
  #endif
#endif /* Configuring Internal RC 8MHz as clock for CPU */

  // Configuring XOSC32K as clock for CPU by multiplying with DFLL
#if defined(XOSC32K)

  // Initializing external 32khz crystal used as a clock source for DFLL
  halXOSC32KInit();

  #if defined(HAL_16MHz)
    #if defined (HAL_USE_USB)
      if (!(SYSCTRL_DFLLCTRL & SYSCTRL_DFLLCTRL_ENABLE))
        halUsbConfigCpuDFLL();
    #else
      // A division factor of 3 is needed as 48MHz/3 = 16MHz
      halConfigCpuDFLL(3, DFLL_MUL_48MHz);
    #endif
  #elif defined(HAL_24MHz)
    #if defined (HAL_USE_USB)
      if (!(SYSCTRL_DFLLCTRL & SYSCTRL_DFLLCTRL_ENABLE))
        halUsbConfigCpuDFLL();
    #else
      // A division factor of 2 is needed as 48MHz/2 = 24MHz
      halConfigCpuDFLL(2, DFLL_MUL_48MHz);
    #endif
  #elif defined(HAL_32MHz)
    #if defined (HAL_USE_USB)
      if (!(SYSCTRL_DPLLCTRLA & SYSCTRL_DPLLCTRLA_ENABLE))
      {
    #endif
      SYSCTRL_INTFLAG |= SYSCTRL_INTFLAG_DPLLLCKR | SYSCTRL_INTFLAG_DPLLLCKF \
                       | SYSCTRL_INTFLAG_DPLLLTO;
      /* Set XOSC32 as clock reference*/
      SYSCTRL_DPLLCTRLB = SYSCTRL_DPLLCTRLB_REFCLK(0);

      /* 32KHz(Fref) * (2999(LDR) + 1) = 96MHz */
      SYSCTRL_DPLLRATIO = SYSCTRL_DPLLRATIO_LDR(2999);

      SYSCTRL_DPLLCTRLA = SYSCTRL_DPLLCTRLA_ENABLE;

      /*Wait untill DPLL is locked*/
      while(!(SYSCTRL_DPLLSTATUS & SYSCTRL_DPLLSTATUS_LOCK));

      /*Configuring CPU clock(GEN0) to 32MHz*/
      GCLK_GENDIV = GCLK_GENDIV_ID(GCLK_GEN_0) | GCLK_GENDIV_DIV(3); // 96/3 = 32MHz
      halGclkSync();
      // Routing the FDPLL output as source to generator 0
      GCLK_GENCTRL = GCLK_GENCTRL_ID(GCLK_GEN_0) | GCLK_GENCTRL_SRC(FDPLL96M) 
                                | GCLK_GENCTRL_GENEN | GCLK_GENCTRL_IDC;
      halGclkSync();

      /*Configuring Peripheral clock(GEN3) to 8MHz*/
      GCLK_GENDIV = GCLK_GENDIV_ID(GCLK_GEN_3) | GCLK_GENDIV_DIV(12);
      halGclkSync();
      // Routing the FDPLL output as source to generator 3
      GCLK_GENCTRL = GCLK_GENCTRL_ID(GCLK_GEN_3) | GCLK_GENCTRL_SRC(FDPLL96M) 
                                | GCLK_GENCTRL_GENEN | GCLK_GENCTRL_IDC;
      halGclkSync();

      #if defined (HAL_USE_USB)
        /*Configuring USB clock(GEN5) to 48MHz*/
        GCLK_GENDIV = GCLK_GENDIV_ID(GCLK_GEN_5) | GCLK_GENDIV_DIV(2); // 96 / 2 = 48  Mhz
        halGclkSync();
        // Routing the FDPLL output as source to generator 5
        GCLK_GENCTRL = GCLK_GENCTRL_ID(GCLK_GEN_5) | GCLK_GENCTRL_SRC(FDPLL96M) 
                              | GCLK_GENCTRL_GENEN | GCLK_GENCTRL_IDC;
        halGclkSync();
      #endif
      #if defined (HAL_USE_USB)
      }
      #endif

  #elif defined(HAL_48MHz)
    #if defined (HAL_USE_USB)
      if (!(SYSCTRL_DFLLCTRL & SYSCTRL_DFLLCTRL_ENABLE))
        halUsbConfigCpuDFLL();
    #else
      // No division factor is needed as the output is 48MHz
      halConfigCpuDFLL(0, DFLL_MUL_48MHz);
    #endif
  #elif defined(HAL_4MHz) || defined(HAL_8MHz)
    #error "Choose HAL_CLOCK_SOURCE as RC_INTERNAL when choosing HAL_4MHz and HAL_8MHz in HAL\Configuration"
  #endif 
#endif /* XOSC32K*/
#endif /* CLKM */
}

#ifndef CLKM
#if (defined(HAL_4MHz) || defined(HAL_8MHz)) && (!defined(HAL_USE_USB))
/**************************************************************************//**
\brief Run CPU from internal 8Mhz RC Oscillator 

\param[in] div - The division factor to be applied before giving the RC clock \
                 to CPU
******************************************************************************/
static void halConfigCpuIntRC(uint8_t div)
{
  // Setting the prescalar for generator 0
  GCLK_GENDIV = GCLK_GENDIV_ID(GCLK_GEN_0) | GCLK_GENDIV_DIV(div);
  halGclkSync();
 
  // Routing the internal RC as source to generator 0
  GCLK_GENCTRL = GCLK_GENCTRL_ID(GCLK_GEN_0) | GCLK_GENCTRL_SRC(OSC8M) | GCLK_GENCTRL_GENEN;
  halGclkSync();
}

#elif defined(HAL_16MHz) || defined(HAL_24MHz) || defined(HAL_48MHz)
/**************************************************************************//**
\brief Run CPU from external XOSC32K Oscillator through DFLL to run at \
       different frequencies.

\param[in] div - The division factor to be applied before giving the DFLL    \
                 clock to CPU.
\param[in] mul - The multiplication factor to be applied on DFLL to multiply \
                 the RC clock.
******************************************************************************/
#if !defined (HAL_USE_USB)
static void halConfigCpuDFLL(uint16_t div, uint16_t mul)
{
  // Setting the prescalar for generator 1
  GCLK_GENDIV = GCLK_GENDIV_ID(GCLK_GEN_1) | GCLK_GENDIV_DIV(0);
  halGclkSync();

  // Routing the XOSC32K as source to generator 1
  GCLK_GENCTRL = GCLK_GENCTRL_ID(GCLK_GEN_1) | GCLK_GENCTRL_SRC(EXOSC32K) | GCLK_GENCTRL_GENEN;
  halGclkSync();

  // Clearing Flags
  SYSCTRL_INTFLAG |= SYSCTRL_INTFLAG_DFLLRDY | SYSCTRL_INTFLAG_DFLLLCKF \
                     | SYSCTRL_INTFLAG_DFLLLCKC;

  // Setting the DFLL mode to closed loop and enabling it
  halDfllReady();
  SYSCTRL_DFLLCTRL = SYSCTRL_DFLLCTRL_ENABLE | SYSCTRL_DFLLCTRL_MODE;

  // Setting the FSTEP, CSTEP and multiplication factor for DFLL
  SYSCTRL_DFLLMUL = SYSCTRL_DFLLMUL_MUL(mul) | SYSCTRL_DFLLMUL_FSTEP(DFLL_FINE_STEP_SIZE) \
                    | SYSCTRL_DFLLMUL_CSTEP(DFLL_COARSE_STEP_SIZE);

  // Routing the clock for DFLL from generator 1
  GCLK_CLKCTRL = GCLK_CLKCTRL_ID(GCLK_DFLL48M_REF) | GCLK_CLKCTRL_GEN(GCLK_GEN_1) | GCLK_CLKCTRL_CLKEN;

  // Waiting for coarse lock to happen
  halCoarseLock();
  // Waiting for fine lock to happen
  halFineLock();

  // Setting the prescalar for generator 0
  GCLK_GENDIV = GCLK_GENDIV_ID(GCLK_GEN_0) | GCLK_GENDIV_DIV(div);
  halGclkSync();

  // Routing the DFLL output as source to generator 0
  GCLK_GENCTRL = GCLK_GENCTRL_ID(GCLK_GEN_0) | GCLK_GENCTRL_SRC(DFLL48M) | GCLK_GENCTRL_GENEN | GCLK_GENCTRL_IDC;
  halGclkSync();
}
#endif
#endif

#if (defined (HAL_USE_USB) && !defined(HAL_4MHz) && !defined(HAL_32MHz))
static void halUsbConfigCpuDFLL(void)
{
  // Clearing Flags
  SYSCTRL_INTFLAG |= SYSCTRL_INTFLAG_DFLLRDY | SYSCTRL_INTFLAG_DFLLLCKF \
                     | SYSCTRL_INTFLAG_DFLLLCKC;
  
  uint32_t coarse =( *((uint32_t *)(NVMCTRL_OTP4)
                    + (NVM_SW_CALIB_DFLL48M_COARSE_VAL / 32))
                    >> (NVM_SW_CALIB_DFLL48M_COARSE_VAL % 32))
                    & ((1 << 6) - 1);
                if (coarse == 0x3f) 
                {
                   coarse = 0x1f;
                }
  uint32_t fine =( *((uint32_t *)(NVMCTRL_OTP4)
    + (NVM_SW_CALIB_DFLL48M_FINE_VAL / 32))
    >> (NVM_SW_CALIB_DFLL48M_FINE_VAL % 32))
    & ((1 << 10) - 1);
  if (fine == 0x3ff)
  {
      fine = 0x1ff;
  }
  SYSCTRL_DFLLCTRL = 0;
  halDfllReady();

  // Setting the FSTEP, CSTEP and multiplication factor for DFLL
  SYSCTRL_DFLLMUL = 48000;
  SYSCTRL_DFLLVAL = SYSCTRL_DFLLVAL_COARSE(coarse) | SYSCTRL_DFLLVAL_FINE(fine) ;
  
  SYSCTRL_DFLLCTRL = SYSCTRL_DFLLCTRL_ENABLE | SYSCTRL_DFLLCTRL_CCDIS | SYSCTRL_DFLLCTRL_USBCRM;
  halDfllReady();

#if defined(HAL_48MHz)
  // Setting the prescalar for generator 0 and 1
  GCLK_GENDIV = GCLK_GENDIV_ID(GCLK_GEN_1) | GCLK_GENDIV_DIV(0);
  GCLK_GENDIV = GCLK_GENDIV_ID(GCLK_GEN_0) | GCLK_GENDIV_DIV(0);
#elif defined(HAL_24MHz)
  GCLK_GENDIV = GCLK_GENDIV_ID(GCLK_GEN_0) | GCLK_GENDIV_DIV(2);
#elif defined(HAL_16MHz)
  GCLK_GENDIV = GCLK_GENDIV_ID(GCLK_GEN_0) | GCLK_GENDIV_DIV(3);
#endif
  halGclkSync();
#if !defined(HAL_8MHz)
  GCLK_GENCTRL = GCLK_GENCTRL_ID(GCLK_GEN_0) | GCLK_GENCTRL_SRC(DFLL48M) | GCLK_GENCTRL_GENEN | GCLK_GENCTRL_IDC;
  halGclkSync();
#endif
  GCLK_GENCTRL = GCLK_GENCTRL_ID(GCLK_GEN_5) | GCLK_GENCTRL_SRC(DFLL48M) | GCLK_GENCTRL_GENEN | GCLK_GENCTRL_IDC;
  halGclkSync();
}
#endif /*#if defined (HAL_USE_USB)*/
#endif /* CLKM */
/**************************************************************************//**
\brief Initialize the 32KHz external Crystal oscillator.
******************************************************************************/
void halXOSC32KInit(void)
{
  /* Start up time for XOSC32K */
  SYSCTRL_XOSC32K_s.startup = SYSTEM_XOSC32K_STARTUP_65536;
  /* External XOSC32K Enable */
  SYSCTRL_XOSC32K_s.xtalen = 1;
 
  /* Auto amplitude control */
  SYSCTRL_XOSC32K_s.aampen = true;
  /* 1KHz output Enable/Disable */
  SYSCTRL_XOSC32K_s.en1k = false;
  /* 32KHz output Enable/Disable */
  SYSCTRL_XOSC32K_s.en32k = true;

  /* On demand feature of the clock module */
  SYSCTRL_XOSC32K_s.ondemand = false;
  /* Run in standby mode feature of the clock */
  SYSCTRL_XOSC32K_s.runstdby = true;
  /* Write once feature of the clock */
  SYSCTRL_XOSC32K_s.wrtlock  = false;
 
  /* Enable the XOSC32K crystal */
  SYSCTRL_XOSC32K_s.enable = true;
 
  /* Check the XOSC32K Clock source is ready to use */
  halCheckXOSC32KReady();
}

/**************************************************************************//**
\brief Initialize the Peripherals with Internal RC oscillator.

\param[in] div - The division factor to be applied before giving the Internal \
                 RC clock to Peripherals.
******************************************************************************/
static void halConfigPeriIntRC(uint8_t div)
{
  // Setting the pre-scalar for generator 3
  GCLK_GENDIV = GCLK_GENDIV_ID(GCLK_GEN_3) | GCLK_GENDIV_DIV(div);
  halGclkSync();

#if defined(HAL_USE_WDT)  
  // Setting the pre-scalar for generator 4
  GCLK_GENDIV = GCLK_GENDIV_ID(GCLK_GEN_4) | GCLK_GENDIV_DIV(32);
  halGclkSync();
#endif // defined(HAL_USE_WDT)

  // Routing the internal RC as source to generator 3
  GCLK_GENCTRL = GCLK_GENCTRL_ID(GCLK_GEN_3) | GCLK_GENCTRL_SRC(OSC8M) | GCLK_GENCTRL_GENEN;
  halGclkSync();

#if defined(HAL_USE_WDT)
  // Routing the OSCULP32K as source to generator 4 as this is routed for WDT
  GCLK_GENCTRL = GCLK_GENCTRL_ID(GCLK_GEN_4) | GCLK_GENCTRL_SRC(OSCULP32K)  \
                 | GCLK_GENCTRL_GENEN;
  halGclkSync();
#endif // defined(HAL_USE_WDT)
}

/**************************************************************************//**
\brief Restore default setup value: enable Main On-Chip RC oscillator running on
8 MHz for Main Clock source.
******************************************************************************/
void halRestoreStartupClock(void)
{
  /* Clock system may be already setup by flash loaders or IAR startup script.
     Restore default settings: CPU is clocked from RC oscillator running on
     8 MHz as Main Clock source. */
  halSwitchToRcClock();
  /* Switch to active clock (RC or XTAL) and perform clock system initialization */
  halSwitchToActiveClock();
}

/**************************************************************************//**
\brief Initialization of the flash controller, the clock source systems and
the watchdog timer.
******************************************************************************/
void halLowLevelInit(void)
{
  halRestoreStartupClock();

#if !defined(HAL_USE_WDT)
  /* Disable watchdog timer */
  WDT_CTRL_s.enable = 0;
#endif

  /* Enable interrupt */
  __enable_irq();
}

#ifdef CLKM
/**************************************************************************//**
\brief Initialization of the CLKM to produce appropriate frequency and also to 
handle the switch from CLKM to OSC8M duing sleep.
******************************************************************************/
void halConfigClkm(SYS_EventId_t eventId, SYS_EventData_t data)
{
  (void)eventId;

  if (data == INITIALIZING_WAKE_UP_STATE)
  {
    phySetFreq();
    halRouteClkm();
  }
  else if ((data == INITIALIZING_SLEEP_STATE) || (data == SWITCH_TO_RC_INTERNAL))
  {
    // Routing the internal RC as source to generator 0
    GCLK_GENCTRL = GCLK_GENCTRL_ID(GCLK_GEN_0) | GCLK_GENCTRL_SRC(OSC8M) | GCLK_GENCTRL_GENEN;
    halGclkSync();

    // Routing the internal RC as source to generator 3
    GCLK_GENCTRL = GCLK_GENCTRL_ID(GCLK_GEN_3) | GCLK_GENCTRL_SRC(OSC8M) | GCLK_GENCTRL_GENEN;
    halGclkSync();

    // Setting the prescalar for generator 0
    GCLK_GENDIV = GCLK_GENDIV_ID(GCLK_GEN_0) | GCLK_GENDIV_DIV(0);
    halGclkSync();

    // Setting the prescalar for generator 3
    GCLK_GENDIV = GCLK_GENDIV_ID(GCLK_GEN_3) | GCLK_GENDIV_DIV(0);
    halGclkSync();

#if defined(HAL_16MHz) || defined(HAL_24MHz) || defined(HAL_48MHz)
    // stopping DFLL
    SYSCTRL_DFLLCTRL = 0;
#elif defined(HAL_32MHz)
    // stopping DPLL
    SYSCTRL_DPLLCTRLA = 0;
#endif

    // Stopping of Routing the GCLKIN as source to generator 1
    GCLK_GENCTRL = GCLK_GENCTRL_ID(GCLK_GEN_1) | GCLK_GENCTRL_SRC(GCLKIN);
    halGclkSync();
    
    HAL_DissableRfClkmPins();
  }
  else if (data == RF_INITIALIZED)
  {
    halRouteClkm();
  }
}

/**************************************************************************//**
\brief Routing Source Generator output to Generator 0
******************************************************************************/
static void halConfigCpuClkm(uint8_t div, uint8_t source)
{
  // Setting the prescalar for generator 0
  GCLK_GENDIV = GCLK_GENDIV_ID(GCLK_GEN_0) | GCLK_GENDIV_DIV(div);
  halGclkSync();

  // Routing the source output as source to generator 0
  GCLK_GENCTRL = GCLK_GENCTRL_ID(GCLK_GEN_0) | GCLK_GENCTRL_SRC(source) | GCLK_GENCTRL_GENEN | GCLK_GENCTRL_IDC;
  halGclkSync();
}

/**************************************************************************//**
\brief Routing Source Generator output to Generator 3 for driving peripherals 
(Gen 5 for USB)
******************************************************************************/
static void halConfigPeriClkm(uint8_t div, uint8_t source)
{
  // Setting the prescalar for generator 3
  GCLK_GENDIV = GCLK_GENDIV_ID(GCLK_GEN_3) | GCLK_GENDIV_DIV(div);
  halGclkSync();

  // Routing the source output as source to generator 3
  GCLK_GENCTRL = GCLK_GENCTRL_ID(GCLK_GEN_3) | GCLK_GENCTRL_SRC(source) | GCLK_GENCTRL_GENEN | GCLK_GENCTRL_IDC;
  halGclkSync();
  #if defined (HAL_USE_USB)
    #if (defined(HAL_8MHz) || defined(HAL_16MHz) || defined(HAL_24MHz) || defined(HAL_48MHz))
      // Setting the prescalar for generator 5
      GCLK_GENDIV = GCLK_GENDIV_ID(GCLK_GEN_5) | GCLK_GENDIV_DIV(0);
    #elif defined(HAL_32MHz)
      // Setting the prescalar for generator 5
      GCLK_GENDIV = GCLK_GENDIV_ID(GCLK_GEN_5) | GCLK_GENDIV_DIV(2);
    #endif // defined(HAL_8MHz)
    halGclkSync();
    // Routing the source output as source to generator 5
    GCLK_GENCTRL = GCLK_GENCTRL_ID(GCLK_GEN_5) | GCLK_GENCTRL_SRC(source) | GCLK_GENCTRL_GENEN | GCLK_GENCTRL_IDC;
    halGclkSync();
  #endif // defined (HAL_USE_USB)
}

#if !defined (HAL_32MHz)
/**************************************************************************//**
\brief Configures DFLL with CLKM source
******************************************************************************/
static void halConfigDfllClkm (void)
{
  // DFLL Configuration
  #if defined (HAL_USE_USB)
    if (!(SYSCTRL_DFLLCTRL & SYSCTRL_DFLLCTRL_ENABLE))
  #endif
  {
    //Clearing System control interrupt Flags
    SYSCTRL_INTFLAG |= SYSCTRL_INTFLAG_DFLLRDY | SYSCTRL_INTFLAG_DFLLLCKF \
                       | SYSCTRL_INTFLAG_DFLLLCKC;

    // Setting the DFLL mode to closed loop and enabling it
    halDfllReady();
    SYSCTRL_DFLLCTRL = SYSCTRL_DFLLCTRL_ENABLE | SYSCTRL_DFLLCTRL_MODE;

    // Setting the FSTEP, CSTEP and multiplication factor for DFLL
    SYSCTRL_DFLLMUL = SYSCTRL_DFLLMUL_MUL(1500) | SYSCTRL_DFLLMUL_FSTEP(DFLL_FINE_STEP_SIZE) \
                      | SYSCTRL_DFLLMUL_CSTEP(DFLL_COARSE_STEP_SIZE);

    // Routing the clock for DFLL from generator 1 (CLKM)
    GCLK_CLKCTRL = GCLK_CLKCTRL_ID(GCLK_DFLL48M_REF) | GCLK_CLKCTRL_GEN(GCLK_GEN_1) | GCLK_CLKCTRL_CLKEN;

    // Waiting for coarse lock to happen
    halCoarseLock();
    // Waiting for fine lock to happen
    halFineLock();
  }
}
#endif
/**************************************************************************//**
\brief Routing CLKM to CPU
******************************************************************************/
static void halRouteClkm(void)
{
  HAL_InitRfClkmPins();

#if (defined(HAL_16MHz) || defined(HAL_24MHz) || defined(HAL_48MHz)) || ( defined(HAL_8MHz) && defined (HAL_USE_USB))
  /* CLKM is configured to generate 8MHz output, So Gen 1 division factor 
  is configured in such a way(8Mhz/250) to get 32Khz as Output frequency which will be 
  fed to DFLL to generate 48MHz clock  */
  GCLK_GENDIV = GCLK_GENDIV_ID(GCLK_GEN_1) | GCLK_GENDIV_DIV(250);
  halGclkSync();
#elif defined(HAL_32MHz)
  /* CLKM is configured to generate 8MHz output, So Gen 1 division factor 
  is configured in such a way(8Mhz/8) to get 1Mhz as Output frequency which will be 
  fed to FDPLL to generate 96MHz clock  */  
  GCLK_GENDIV = GCLK_GENDIV_ID(GCLK_GEN_1) | GCLK_GENDIV_DIV(8);
  halGclkSync();
#elif defined(HAL_4MHz) || defined(HAL_8MHz)
  /* CLKM is configured to generate 8MHz output, So Gen 1 division factor 
  is configured as 0 to get same 8MHz as Output frequency which will be 
  fed directly to CPU ands peripherals. No need for DFLL*/
  GCLK_GENDIV = GCLK_GENDIV_ID(GCLK_GEN_1) | GCLK_GENDIV_DIV(0);
  halGclkSync();
#endif

  // Routing the GCLKIN as source to generator 1
  GCLK_GENCTRL = GCLK_GENCTRL_ID(GCLK_GEN_1) | GCLK_GENCTRL_SRC(GCLKIN) | GCLK_GENCTRL_GENEN;
  halGclkSync();

#if defined(HAL_16MHz) || defined(HAL_24MHz) || defined(HAL_48MHz)
  halConfigDfllClkm ();
#elif defined (HAL_32MHz)
  // FDPLL Configuration
  // Clearing Flags
  #if defined (HAL_USE_USB)
    if (!(SYSCTRL_DPLLCTRLA & SYSCTRL_DPLLCTRLA_ENABLE))
  #endif
  {
    SYSCTRL_INTFLAG |= SYSCTRL_INTFLAG_DPLLLCKR | SYSCTRL_INTFLAG_DPLLLCKF \
                     | SYSCTRL_INTFLAG_DPLLLTO;

    /*From GEN 1 we will get 1MHz clock
     1MHz(Fref) * (95(LDR) + 1) = 96MHz*/
    SYSCTRL_DPLLRATIO = SYSCTRL_DPLLRATIO_LDR(95);

    /* Set GCLK_DPLL as clock reference*/
    SYSCTRL_DPLLCTRLB = SYSCTRL_DPLLCTRLB_REFCLK(2);

    // Routing the clock for DPLL from generator 1
    GCLK_CLKCTRL = GCLK_CLKCTRL_ID(GCLK_DPLL) | GCLK_CLKCTRL_GEN(GCLK_GEN_1) | GCLK_CLKCTRL_CLKEN;

    SYSCTRL_DPLLCTRLA = SYSCTRL_DPLLCTRLA_ENABLE;

    /*Wait untill DPLL is locked*/
    while(!(SYSCTRL_DPLLSTATUS & SYSCTRL_DPLLSTATUS_LOCK));
  }
#endif

#if defined(HAL_4MHz)
  halConfigCpuClkm(0,GCLKGEN1);
  halConfigPeriClkm(0,GCLKGEN1);
#elif defined(HAL_8MHz)
  #if defined (HAL_USE_USB)
    halConfigDfllClkm();
    halConfigCpuClkm(6,DFLL48M);
    halConfigPeriClkm(6,DFLL48M);
  #else
    halConfigCpuClkm(0,GCLKGEN1);
    halConfigPeriClkm(0,GCLKGEN1);
  #endif
#elif defined(HAL_16MHz)
  halConfigCpuClkm(3,DFLL48M);
  halConfigPeriClkm(6,DFLL48M);
#elif defined(HAL_24MHz)
  halConfigCpuClkm(2,DFLL48M);
  halConfigPeriClkm(6,DFLL48M);
#elif defined(HAL_32MHz)
  halConfigCpuClkm(3,FDPLL96M);
  halConfigPeriClkm(12,FDPLL96M);
#elif defined(HAL_48MHz)
  halConfigCpuClkm(0,DFLL48M);
  halConfigPeriClkm(6,DFLL48M);
#endif
}
#endif

// eof halLowLevelInit.c
